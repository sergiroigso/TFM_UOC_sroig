---
title: "scRNAseq analysis"
author: "Sergi Roig"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_depth: 3
    toc_float: true
    theme: cosmo
    highlight: textmate
    number_sections: true
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: '3'
  word_document:
    toc: true
    toc_depth: '3'
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
## Global options
library(knitr)
library(rmdformats)
library(tinytex)
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE, tidy.opts = list(width.cutoff = 60))
```

```{r packages, message=FALSE, warning=FALSE}
library(Seurat)
library(ggplot2)
library(SingleR)
library(dplyr)
library(celldex)
library(RColorBrewer)
library(SingleCellExperiment)
library(patchwork)
library(reshape2)
library(hdf5r)
library(speckle)
library(tidyverse)
library(compositions)
library(knitr)
library(pheatmap)
```



# Data loading

```{r data loading}
# read the filtered Cell Ranger h5 matrices
spl_WT <- Read10X_h5("DATA/WT_SPsample_filtered_feature_bc_matrix.h5")
spl_KO <- Read10X_h5("DATA/KO_SP_sample_filtered_feature_bc_matrix.h5")
bm_WT  <- Read10X_h5("DATA/WT_BM_sample_filtered_feature_bc_matrix.h5")
bm_KO  <- Read10X_h5("DATA/KO_BM_sample_filtered_feature_bc_matrix.h5")

# create the appropriate Seurat
spl_WT_obj <- CreateSeuratObject(spl_WT, project = "spl_WT")
spl_KO_obj <- CreateSeuratObject(spl_KO, project = "spl_KO")
bm_WT_obj  <- CreateSeuratObject(bm_WT, project = "bm_WT")
bm_KO_obj  <- CreateSeuratObject(bm_KO, project = "bm_KO")

# let’s remove matrices to save memory
rm(spl_WT)
rm(spl_KO)
rm(bm_WT)
rm(bm_KO)
```

# Preliminar filter

## WT spleen

```{r filtering plots WT spleen}
#### SPLEEN WT

# mitochondrial genes and ribosomal proteins
spl_WT_obj[["percent.mt"]]  <- PercentageFeatureSet(spl_WT_obj, pattern = "^mt-")
spl_WT_obj[["percent.rb"]] <- PercentageFeatureSet(spl_WT_obj, pattern = "^Rps|^Rpl")
# doublets
doub_spl_WT <- read.csv("data/SCRUBLET/scrublet_WT_spl.csv",header = T,row.names = 1)
colnames(doub_spl_WT) <- c("Doublet_score","Is_doublet")
spl_WT_obj <- AddMetaData(spl_WT_obj,doub_spl_WT)

# filtering
spl_WT_obj[['QC']] <- ifelse(spl_WT_obj@meta.data$Is_doublet == 'True','Doublet','Pass')
spl_WT_obj[['QC']] <- ifelse(spl_WT_obj@meta.data$nFeature_RNA < 500 & spl_WT_obj@meta.data$QC == 'Pass','Low_nFeature',spl_WT_obj@meta.data$QC)
spl_WT_obj[['QC']] <- ifelse(spl_WT_obj@meta.data$nFeature_RNA < 500 & spl_WT_obj@meta.data$QC != 'Pass' & spl_WT_obj@meta.data$QC != 'Low_nFeature',paste('Low_nFeature',spl_WT_obj@meta.data$QC,sep = ','),spl_WT_obj@meta.data$QC)
spl_WT_obj[['QC']] <- ifelse(spl_WT_obj@meta.data$percent.mt > 15 & spl_WT_obj@meta.data$QC == 'Pass','High_MT',spl_WT_obj@meta.data$QC)
spl_WT_obj[['QC']] <- ifelse(spl_WT_obj@meta.data$nFeature_RNA < 500 & spl_WT_obj@meta.data$QC != 'Pass' & spl_WT_obj@meta.data$QC != 'High_MT',paste('High_MT',spl_WT_obj@meta.data$QC,sep = ','),spl_WT_obj@meta.data$QC)
table(spl_WT_obj[['QC']])
```

## PrimPol KO spleen

```{r filtering plots KO spleen}
#### SPLEEN KO

## PrimPol KO spleen
spl_KO_obj[["percent.mt"]]  <- PercentageFeatureSet(spl_KO_obj, pattern = "^mt-")
spl_KO_obj[["percent.rb"]] <- PercentageFeatureSet(spl_KO_obj, pattern = "^Rps|^Rpl")
# doublets
doub_spl_KO <- read.csv("data/SCRUBLET/scrublet_KO_spl.csv",header = T,row.names = 1)
colnames(doub_spl_KO) <- c("Doublet_score","Is_doublet")
spl_KO_obj <- AddMetaData(spl_KO_obj,doub_spl_KO)


# filtering
spl_KO_obj[['QC']] <- ifelse(spl_KO_obj@meta.data$Is_doublet == 'True','Doublet','Pass')
spl_KO_obj[['QC']] <- ifelse(spl_KO_obj@meta.data$nFeature_RNA < 500 & spl_KO_obj@meta.data$QC == 'Pass','Low_nFeature',spl_KO_obj@meta.data$QC)
spl_KO_obj[['QC']] <- ifelse(spl_KO_obj@meta.data$nFeature_RNA < 500 & spl_KO_obj@meta.data$QC != 'Pass' & spl_KO_obj@meta.data$QC != 'Low_nFeature',paste('Low_nFeature',spl_KO_obj@meta.data$QC,sep = ','),spl_KO_obj@meta.data$QC)
spl_KO_obj[['QC']] <- ifelse(spl_KO_obj@meta.data$percent.mt > 15 & spl_KO_obj@meta.data$QC == 'Pass','High_MT',spl_KO_obj@meta.data$QC)
spl_KO_obj[['QC']] <- ifelse(spl_KO_obj@meta.data$nFeature_RNA < 500 & spl_KO_obj@meta.data$QC != 'Pass' & spl_KO_obj@meta.data$QC != 'High_MT',paste('High_MT',spl_KO_obj@meta.data$QC,sep = ','),spl_KO_obj@meta.data$QC)
table(spl_KO_obj[['QC']])
```

## WT bone marrow

```{r filtering plots WT BM}
#### BONE MARROW WT

bm_WT_obj[["percent.mt"]]  <- PercentageFeatureSet(bm_WT_obj, pattern = "^mt-")
bm_WT_obj[["percent.rb"]] <- PercentageFeatureSet(bm_WT_obj, pattern = "^Rps|^Rpl")
# doublets
doub_bm_WT <- read.csv("data/SCRUBLET/scrublet_WT_BM.csv",header = T,row.names = 1)
colnames(doub_bm_WT) <- c("Doublet_score","Is_doublet")
bm_WT_obj <- AddMetaData(bm_WT_obj,doub_bm_WT)

# filtering
bm_WT_obj[['QC']] <- ifelse(bm_WT_obj@meta.data$Is_doublet == 'True','Doublet','Pass')
bm_WT_obj[['QC']] <- ifelse(bm_WT_obj@meta.data$nFeature_RNA < 500 & bm_WT_obj@meta.data$QC == 'Pass','Low_nFeature',bm_WT_obj@meta.data$QC)
bm_WT_obj[['QC']] <- ifelse(bm_WT_obj@meta.data$nFeature_RNA < 500 & bm_WT_obj@meta.data$QC != 'Pass' & bm_WT_obj@meta.data$QC != 'Low_nFeature',paste('Low_nFeature',bm_WT_obj@meta.data$QC,sep = ','),bm_WT_obj@meta.data$QC)
bm_WT_obj[['QC']] <- ifelse(bm_WT_obj@meta.data$percent.mt > 15 & bm_WT_obj@meta.data$QC == 'Pass','High_MT',bm_WT_obj@meta.data$QC)
bm_WT_obj[['QC']] <- ifelse(bm_WT_obj@meta.data$nFeature_RNA < 500 & bm_WT_obj@meta.data$QC != 'Pass' & bm_WT_obj@meta.data$QC != 'High_MT',paste('High_MT',bm_WT_obj@meta.data$QC,sep = ','),bm_WT_obj@meta.data$QC)
table(bm_WT_obj[['QC']])
```

## PrimPol KO bone marrow

```{r filtering plots KO BM}
#### BONE MARROW PRIMPOL KO

bm_KO_obj[["percent.mt"]]  <- PercentageFeatureSet(bm_KO_obj, pattern = "^mt-")
bm_KO_obj[["percent.rb"]] <- PercentageFeatureSet(bm_KO_obj, pattern = "^Rps|^Rpl")
# doublets
doub_bm_KO <- read.csv("data/SCRUBLET/scrublet_KO_BM.csv",header = T,row.names = 1)
colnames(doub_bm_KO) <- c("Doublet_score","Is_doublet")
bm_KO_obj <- AddMetaData(bm_KO_obj,doub_bm_KO)

# filtering
bm_KO_obj[['QC']] <- ifelse(bm_KO_obj@meta.data$Is_doublet == 'True','Doublet','Pass')
bm_KO_obj[['QC']] <- ifelse(bm_KO_obj@meta.data$nFeature_RNA < 500 & bm_KO_obj@meta.data$QC == 'Pass','Low_nFeature',bm_KO_obj@meta.data$QC)
bm_KO_obj[['QC']] <- ifelse(bm_KO_obj@meta.data$nFeature_RNA < 500 & bm_KO_obj@meta.data$QC != 'Pass' & bm_KO_obj@meta.data$QC != 'Low_nFeature',paste('Low_nFeature',bm_KO_obj@meta.data$QC,sep = ','),bm_KO_obj@meta.data$QC)
bm_KO_obj[['QC']] <- ifelse(bm_KO_obj@meta.data$percent.mt > 15 & bm_KO_obj@meta.data$QC == 'Pass','High_MT',bm_KO_obj@meta.data$QC)
bm_KO_obj[['QC']] <- ifelse(bm_KO_obj@meta.data$nFeature_RNA < 500 & bm_KO_obj@meta.data$QC != 'Pass' & bm_KO_obj@meta.data$QC != 'High_MT',paste('High_MT',bm_KO_obj@meta.data$QC,sep = ','),bm_KO_obj@meta.data$QC)
table(bm_KO_obj[['QC']])
```


# Spleen

## Filtering

```{r}
# filter
spl_WT_obj_pass <- subset(spl_WT_obj, subset = QC == "Pass")
spl_KO_obj_pass <- subset(spl_KO_obj, subset = QC == "Pass")

spl_WT_obj_pass$condition <- "WT"
spl_KO_obj_pass$condition <- "KO"
```

## Integration, normalization

```{r}
# list creation
spl_list <- list(spl_WT = spl_WT_obj_pass, spl_KO = spl_KO_obj_pass)
# normalization
for (i in 1:length(spl_list)) {
  spl_list[[i]] <- NormalizeData(spl_list[[i]], verbose = F)
  spl_list[[i]] <- FindVariableFeatures(spl_list[[i]], selection.method = "vst", nfeatures = 2000, verbose = F)
}

# to find integration anchors and actually perform integration
spl_anchors <- FindIntegrationAnchors(object.list = spl_list, dims = 1:30)
spl_seurat <- IntegrateData(anchorset = spl_anchors, dims = 1:30)

# to save ram
rm(spl_list, spl_anchors)


# PCA and UMAP
DefaultAssay(spl_seurat) <- "integrated"
spl_seurat <- ScaleData(spl_seurat, verbose = F)
spl_seurat <- RunPCA(spl_seurat, npcs = 30, verbose = F)
spl_seurat <- RunUMAP(spl_seurat, reduction = "pca", dims = 1:30, verbose = F)

DimPlot(spl_seurat, reduction = "umap") + 
  plot_annotation(title = "Spleen, after integration (Seurat 3)")
```

If we split:

```{r}
# split
DimPlot(spl_seurat, reduction = "umap", split.by = "orig.ident") + NoLegend()
```

## Clusterization

```{r}
# clustering
# to test several clusters
# let's cluster with 0.2 resolution
spl_seurat <- FindNeighbors(spl_seurat, dims = 1:30, k.param = 10, verbose = F)
spl_seurat <- FindClusters(spl_seurat, verbose = F, resolution = 0.2)
DimPlot(spl_seurat,label = T) + NoLegend()
```

Let's see the table:

```{r}
# table with the cluster
count_table <- table(spl_seurat@meta.data$seurat_clusters, spl_seurat@meta.data$orig.ident)
count_table
```


## Annotation

###  Manual annotation using STRING-db

```{r}
# Paso 1: Define las anotaciones para los 16 clústeres
annotations <- c(
  "B cells",                    # cluster 0
  "Ribonucleoproteins",         # cluster 1
  "MHC",                        # cluster 2
  "Chaperone protein folding",  # cluster 3
  "Macrophages-innate response",  # cluster 4
  "Macrophages-phagocytosis",   # cluster 5
  "T cell activation",          # cluster 6
  "NK regulation",          # cluster 7
  "DNA replication",                  # cluster 8
  "ERAD-pathway",    # cluster 9
  "DNA replication",          # cluster 10
  "Antigen presentation",      # cluster 11
  "Nitrogen metabolism",                   # cluster 12
  "Granulocytes",          # cluster 13
  "DNA replication", # cluster 14
  "NK regulation",       # cluster 15
  "NK cells", # cluster 16
  "NK regulation", # cluster 17
  "Leukocyte"  # cluster 18
)

# Asegurar que las anotaciones estén bien nombradas
names(annotations) <- as.character(0:18)

# Paso 2: Obtener el vector de clúster por celda
cluster_ids <- spl_seurat$seurat_clusters
names(cluster_ids) <- colnames(spl_seurat)

# Paso 3: Mapear anotaciones por celda
cluster_annotations <- annotations[as.character(cluster_ids)]

# Paso 4: Añadir al metadata
spl_seurat@meta.data$cluster_annotation_string <- cluster_annotations

# Visualizar
DimPlot(spl_seurat, group.by = "cluster_annotation_string", label = TRUE, repel = TRUE) + NoLegend()
```

### Compositional analysis

```{r}
#### compositional data analysis

# Calcular tabla de conteo por cluster y condición
count_table <- table(spl_seurat@meta.data$seurat_clusters, spl_seurat@meta.data$orig.ident)

# Convertir a matriz y normalizar a proporciones
counts <- as.matrix(count_table)
counts[counts == 0] <- 1e-6
props <- sweep(counts, 2, colSums(counts), FUN = "/")

# Crear data.frame largo
df_long <- data.frame(
  cluster = rep(rownames(props), times = ncol(props)),
  condition = rep(colnames(props), each = nrow(props)),
  proportion = as.vector(props)
)

# Mapear nombres descriptivos de los clusters
df_long$cluster_name <- annotations[as.character(df_long$cluster)]

# Definir orden de las condiciones (WT primero, luego KO)
df_long$condition <- factor(df_long$condition, levels = c("spl_WT", "spl_KO"))

# Ordenar clusters por nombre (o en el orden original si prefieres)
df_long$cluster_name <- factor(df_long$cluster_name, levels = unique(annotations))

# Crear paleta de colores sin repetir
n_clusters <- length(unique(df_long$cluster_name))
colors <- colorRampPalette(brewer.pal(12, "Paired"))(n_clusters)

# Gráfico final con nombres de clúster
ggplot(df_long, aes(x=condition, y=proportion, fill=cluster_name)) +
  geom_bar(stat="identity") +
  theme_minimal() +
  ylab("Cell proportions") +
  xlab("Condition") +
  scale_fill_manual(values=colors, name="Cluster") +
  ggtitle("Cluster distribution by condition") +
  theme(axis.text.x = element_text(angle=45, hjust=1))
```

Some statistics:

```{r}
# algo de estadística
# primero, hay diferencias entre wt y ko?
chisq.test(counts)

# ahora, vamos necesitamos construir una tabla 2×2 para cada cluster, comparando:
# ese cluster vs todos los demás, en las dos condiciones (spl_KO, spl_WT)
# el test evalúa si ese cluster está sobrerrepresentado o infrarrepresentado en KO respecto a WT.

pvals <- apply(counts, 1, function(x) {
  # x = c(spl_KO_cluster, spl_WT_cluster)
  rest_KO <- sum(counts[, "spl_KO"]) - x[1]
  rest_WT <- sum(counts[, "spl_WT"]) - x[2]
  
  mat <- matrix(c(x[1], x[2], rest_KO, rest_WT), nrow = 2)
  fisher.test(mat)$p.value
})
# Añadimos resultados
results <- data.frame(
  Cluster = rownames(counts),
  p.value = pvals,
  adj.p.value = p.adjust(pvals, method = "BH")
)
# Log2 fold change de proporción KO vs WT
log2fc <- log2(props[, "spl_KO"] / props[, "spl_WT"])
results$log2FC <- log2fc
results <- results[order(results$p.value), ]
# Añadir nombres descriptivos de los clusters
results$cluster_name <- annotations[as.character(results$Cluster)]
kable(results)
```

La gráfica: 

```{r}
# podemos plotear
ggplot(results, aes(x = log2FC, y = -log10(p.value), label = cluster_name)) +
  geom_point(aes(color = adj.p.value < 0.05), size = 3, alpha = 0.8) +
  geom_text(data = subset(results, adj.p.value < 0.05),
            vjust = -0.8, size = 3.2, color = "black") +
  scale_color_manual(values = c("grey60", "red")) +
  theme_minimal() +
  labs(x = "log2(FC KO vs WT)",
       y = "-log10(p-value)",
       color = "Significant (FDR < 0.05)",
       title = "Cluster proportion changes (KO vs WT)") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50")
```



```{r}
# --- Preparación: normalizar por cluster (fila) para que cada cluster sea 100% ---
# counts: matrix con filas = clusters, columnas = condiciones (ej. bm_KO, bm_WT)

# Normalizar por fila (cada fila suma 1)
row_props <- sweep(counts, 1, rowSums(counts), FUN = "/")
# Convertir a porcentajes

row_percent <- row_props * 100

# Asegurar orden de clusters si tienen nombres numéricos:
if(all(rownames(row_percent) %in% as.character(as.numeric(rownames(row_percent))))) {
  row_percent <- row_percent[order(as.numeric(rownames(row_percent))), , drop = FALSE]
}

# Transponer para heatmap: filas = condiciones, columnas = clusters
heatmap_mat <- t(row_percent)

# Reordenar filas (condiciones) si quieres WT primero:
desired_cond_order <- c("spl_WT", "spl_KO")
if(all(desired_cond_order %in% rownames(heatmap_mat))) {
  heatmap_mat <- heatmap_mat[desired_cond_order, , drop = FALSE]
}
```

```{r}
pheatmap(
  heatmap_mat,
  cluster_rows = FALSE,   # no reagrupar condiciones
  cluster_cols = FALSE,   # no reagrupar clusters
  color =  colorRampPalette(c("white", "steelblue"))(100),
  display_numbers = TRUE,
  number_format = "%.1f", # formato con 1 decimal
  fontsize_number = 10,
  main = "Percentage of cells per cluster (each cluster = 100%)",
  legend = TRUE,
  angle_col = 45
)
```


If we plot differences by cluster:

```{r}
# Diferencia relativa por cluster (descriptivo)
# Crear tabla de diferencia KO - WT por cluster
diff_df <- df_long %>%
  pivot_wider(names_from = condition, values_from = proportion) %>%
  mutate(diff = spl_KO - spl_WT)
# Barras naranjas → más abundantes en KO
# Barras darkred → más abundantes en WT

# Cluster como factor, niveles invertidos para coord_flip()
diff_df$cluster <- factor(diff_df$cluster, levels = rev(as.character(0:18)))

# Gráfico
ggplot(diff_df, aes(x=cluster, y=diff, fill=diff > 0)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values=c("darkred","orange"), guide=FALSE) +
  theme_minimal() +
  ylab("Difference KO - WT") +
  xlab("Cluster") +
  ggtitle("Clusters changing between KO and WT") +
  coord_flip()
```

### Immune annotation

```{r}
### annotation unbiased using reference

expr <- GetAssayData(spl_seurat, assay = "integrated", slot = "data")

spl_sce <- SingleCellExperiment(
  assays = list(logcounts = expr),
  colData = spl_seurat@meta.data
)

# Referencia de ratón
# otro puede ser:
# MouseRNAseqData()
ref <- celldex::ImmGenData()

pred_spl <- SingleR(test = spl_sce, ref = ref, labels = ref$label.fine)

# Añadir anotación al Seurat
spl_seurat$SingleR_labels <- pred_spl$labels
spl_seurat$SingleR_clean <- gsub("\\s*\\([^\\)]+\\)", "", spl_seurat$SingleR_labels)

DimPlot(spl_seurat, group.by = "SingleR_clean", label = TRUE, repel = TRUE) + NoLegend()
```

### Compositional analysis 

```{r}
#### compositional data analysis

#  count_table con nombres de clusters reales
count_table <- table(spl_seurat@meta.data$SingleR_clean,
                     spl_seurat@meta.data$orig.ident)

# Convertir a matriz
counts <- as.matrix(count_table)

# Reemplazar ceros por un valor pequeño
counts[counts == 0] <- 1e-6

# Proporciones por columna
props <- sweep(counts, 2, colSums(counts), FUN = "/")

# df_long
df_long <- data.frame(
  cluster = rep(rownames(props), times = ncol(props)),
  condition = rep(colnames(props), each = nrow(props)),
  proportion = as.vector(props)
)

# Definir orden de condiciones (WT primero, luego KO)
df_long$condition <- factor(df_long$condition, levels = c("spl_WT", "spl_KO"))

# Orden de clusters según el orden en props
df_long$cluster <- factor(df_long$cluster, levels = rownames(props))

# Paleta con colores únicos
n_clusters <- length(unique(df_long$cluster))
colors <- colorRampPalette(brewer.pal(12, "Paired"))(n_clusters)

# Gráfico
ggplot(df_long, aes(x=condition, y=proportion, fill=cluster)) +
  geom_bar(stat="identity") +
  theme_minimal() +
  ylab("Cell proportions") +
  xlab("Condition") +
  scale_fill_manual(values=colors, name="Cluster") +
  ggtitle("Cluster distribution by condition")
```

```{r}
# --- Preparación: normalizar por cluster (fila) para que cada cluster sea 100% ---
# counts: matrix con filas = clusters, columnas = condiciones (ej. bm_KO, bm_WT)

# Normalizar por fila (cada fila suma 1)
row_props <- sweep(counts, 1, rowSums(counts), FUN = "/")
# Convertir a porcentajes
row_percent <- row_props * 100

# Asegurar orden de clusters si tienen nombres numéricos:
if(all(rownames(row_percent) %in% as.character(as.numeric(rownames(row_percent))))) {
  row_percent <- row_percent[order(as.numeric(rownames(row_percent))), , drop = FALSE]
}

# Transponer para heatmap: filas = condiciones, columnas = clusters
heatmap_mat <- t(row_percent)

# Reordenar filas (condiciones) si quieres WT primero:
desired_cond_order <- c("spl_WT", "spl_KO")
if(all(desired_cond_order %in% rownames(heatmap_mat))) {
  heatmap_mat <- heatmap_mat[desired_cond_order, , drop = FALSE]
}

pheatmap(
  heatmap_mat,
  cluster_rows = FALSE,   # no reagrupar condiciones
  cluster_cols = FALSE,   # no reagrupar clusters
  color = colorRampPalette(c("white", "steelblue"))(100),
  display_numbers = TRUE,
  number_format = "%.1f", # formato con 1 decimal
  fontsize_number = 10,
  main = "Percentage of cells per cluster (each cluster = 100%)",
  legend = TRUE,
  angle_col = 45
)
```


Some statistics:

```{r}
# algo de estadística
# primero, hay diferencias entre wt y ko?
chisq.test(counts)

# ahora, vamos necesitamos construir una tabla 2×2 para cada cluster, comparando:
# ese cluster vs todos los demás, en las dos condiciones (spl_KO, spl_WT)
# el test evalúa si ese cluster está sobrerrepresentado o infrarrepresentado en KO respecto a WT.

pvals <- apply(counts, 1, function(x) {
  # x = c(spl_KO_cluster, spl_WT_cluster)
  rest_KO <- sum(counts[, "spl_KO"]) - x[1]
  rest_WT <- sum(counts[, "spl_WT"]) - x[2]
  
  mat <- matrix(c(x[1], x[2], rest_KO, rest_WT), nrow = 2)
  fisher.test(mat)$p.value
})
# Añadimos resultados
results <- data.frame(
  Cluster = rownames(counts),
  p.value = pvals,
  adj.p.value = p.adjust(pvals, method = "BH")
)
# Log2 fold change de proporción KO vs WT
log2fc <- log2(props[, "spl_KO"] / props[, "spl_WT"])
results$log2FC <- log2fc
# Añadir nombres descriptivos de los clusters
results$cluster_name <- annotations[as.character(results$Cluster)]
kable(results)
```

La gráfica: 

```{r}
# podemos plotear
ggplot(results, aes(x = log2FC, y = -log10(p.value), label = Cluster)) +
  geom_point(aes(color = adj.p.value < 0.05), size = 3, alpha = 0.8) +
  geom_text(data = subset(results, adj.p.value < 0.05),
            vjust = -0.8, size = 3.2, color = "black") +
  scale_color_manual(values = c("grey60", "red")) +
  theme_minimal() +
  labs(x = "log2(FC KO vs WT)",
       y = "-log10(p-value)",
       color = "Significant (FDR < 0.05)",
       title = "Cluster proportion changes (KO vs WT)") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50")
```


### MouseRNAseqData

```{r}
### annotation unbiased using reference

expr <- GetAssayData(spl_seurat, assay = "integrated", slot = "data")

spl_sce <- SingleCellExperiment(
  assays = list(logcounts = expr),
  colData = spl_seurat@meta.data
)

# Referencia de ratón
# otro puede ser:
# MouseRNAseqData()
ref <- celldex::MouseRNAseqData()

pred_spl <- SingleR(test = spl_sce, ref = ref, labels = ref$label.fine)

# Añadir anotación al Seurat
spl_seurat$SingleR_labels <- pred_spl$labels
spl_seurat$SingleR_clean <- gsub("\\s*\\([^\\)]+\\)", "", spl_seurat$SingleR_labels)

DimPlot(spl_seurat, group.by = "SingleR_clean", label = TRUE, repel = TRUE) + NoLegend()
```

### Compositional analysis 

```{r}
#### compositional data analysis

#  count_table con nombres de clusters reales
count_table <- table(spl_seurat@meta.data$SingleR_clean,
                     spl_seurat@meta.data$orig.ident)

# Convertir a matriz
counts <- as.matrix(count_table)

# Reemplazar ceros por un valor pequeño
counts[counts == 0] <- 1e-6

# Proporciones por columna
props <- sweep(counts, 2, colSums(counts), FUN = "/")

# df_long
df_long <- data.frame(
  cluster = rep(rownames(props), times = ncol(props)),
  condition = rep(colnames(props), each = nrow(props)),
  proportion = as.vector(props)
)

# Definir orden de condiciones (WT primero, luego KO)
df_long$condition <- factor(df_long$condition, levels = c("spl_WT", "spl_KO"))

# Orden de clusters según el orden en props
df_long$cluster <- factor(df_long$cluster, levels = rownames(props))

# Paleta con colores únicos
n_clusters <- length(unique(df_long$cluster))
colors <- colorRampPalette(brewer.pal(12, "Paired"))(n_clusters)

# Gráfico
ggplot(df_long, aes(x=condition, y=proportion, fill=cluster)) +
  geom_bar(stat="identity") +
  theme_minimal() +
  ylab("Cell proportions") +
  xlab("Condition") +
  scale_fill_manual(values=colors, name="Cluster") +
  ggtitle("Cluster distribution by condition")
```

```{r}
# --- Preparación: normalizar por cluster (fila) para que cada cluster sea 100% ---
# counts: matrix con filas = clusters, columnas = condiciones (ej. bm_KO, bm_WT)

# Normalizar por fila (cada fila suma 1)
row_props <- sweep(counts, 1, rowSums(counts), FUN = "/")
# Convertir a porcentajes
row_percent <- row_props * 100

# Asegurar orden de clusters si tienen nombres numéricos:
if(all(rownames(row_percent) %in% as.character(as.numeric(rownames(row_percent))))) {
  row_percent <- row_percent[order(as.numeric(rownames(row_percent))), , drop = FALSE]
}

# Transponer para heatmap: filas = condiciones, columnas = clusters
heatmap_mat <- t(row_percent)

# Reordenar filas (condiciones) si quieres WT primero:
desired_cond_order <- c("spl_WT", "spl_KO")
if(all(desired_cond_order %in% rownames(heatmap_mat))) {
  heatmap_mat <- heatmap_mat[desired_cond_order, , drop = FALSE]
}

pheatmap(
  heatmap_mat,
  cluster_rows = FALSE,   # no reagrupar condiciones
  cluster_cols = FALSE,   # no reagrupar clusters
  color = colorRampPalette(c("white", "steelblue"))(100),
  display_numbers = TRUE,
  number_format = "%.1f", # formato con 1 decimal
  fontsize_number = 10,
  main = "Percentage of cells per cluster (each cluster = 100%)",
  legend = TRUE,
  angle_col = 45
)
```

# Bone marrow

## Filtering

```{r}
# filter
bm_WT_obj_pass <- subset(bm_WT_obj, subset = QC == "Pass")
bm_KO_obj_pass <- subset(bm_KO_obj, subset = QC == "Pass")

bm_WT_obj_pass$condition <- "WT"
bm_KO_obj_pass$condition <- "KO"
```

## Integration, normalization

```{r}
# list creation
bm_list <- list(bm_WT = bm_WT_obj_pass, bm_KO = bm_KO_obj_pass)
# normalization
for (i in 1:length(bm_list)) {
  bm_list[[i]] <- NormalizeData(bm_list[[i]], verbose = F)
  bm_list[[i]] <- FindVariableFeatures(bm_list[[i]], selection.method = "vst", nfeatures = 2000, verbose = F)
}

# to find integration anchors and actually perform integration
bm_anchors <- FindIntegrationAnchors(object.list = bm_list, dims = 1:30)
bm_seurat <- IntegrateData(anchorset = bm_anchors, dims = 1:30)

# to save ram
rm(bm_list, bm_anchors)


# PCA and UMAP
DefaultAssay(bm_seurat) <- "integrated"
bm_seurat <- ScaleData(bm_seurat, verbose = F)
bm_seurat <- RunPCA(bm_seurat, npcs = 30, verbose = F)
bm_seurat <- RunUMAP(bm_seurat, reduction = "pca", dims = 1:30, verbose = F)

DimPlot(bm_seurat, reduction = "umap") + 
  plot_annotation(title = "bm, after integration (Seurat 3)")
```

If we split:

```{r}
# split
DimPlot(bm_seurat, reduction = "umap", split.by = "orig.ident") + NoLegend()
```

## Clusterization

```{r}
# clustering
# to test several clusters
# let's cluster with 0.2 resolution
bm_seurat <- FindNeighbors(bm_seurat, dims = 1:30, k.param = 10, verbose = F)
bm_seurat <- FindClusters(bm_seurat, verbose = F, resolution = 0.2)
DimPlot(bm_seurat,label = T) + NoLegend()
```

Let's see the table:

```{r}
# table with the cluster
count_table <- table(bm_seurat@meta.data$seurat_clusters, bm_seurat@meta.data$orig.ident)
kable(count_table)
```

## Annotation

###  Manual annotation using STRING-db

```{r}
# Paso 1: Define las anotaciones para los 16 clústeres
annotations <- c(
  "Macrophages/interferon",  # cluster 0
  "Platelet",                # cluster 1
  "DNA replication",         # cluster 2
  "T cells",                 # cluster 3
  "B cells",                 # cluster 4
  "Protein folding",         # cluster 5
  "Phagocytosis",            # cluster 6
  "Erythrocytes",            # cluster 7
  "Megakaryocytes",          # cluster 8
  "Platelet",                # cluster 9
  "Cell migration",          # cluster 10
  "B cells/ERAD",            # cluster 11
  "Antigen presentation",    # cluster 12
  "Cell migration",          # cluster 13
  "Antigen presentation",    # cluster 14
  "NK"                       # cluster 15
)

# Asegurar que las anotaciones estén bien nombradas
names(annotations) <- as.character(0:15)

# Paso 2: Obtener el vector de clúster por celda
cluster_ids <- bm_seurat$seurat_clusters
names(cluster_ids) <- colnames(bm_seurat)

# Paso 3: Mapear anotaciones por celda
cluster_annotations <- annotations[as.character(cluster_ids)]

# Paso 4: Añadir al metadata
bm_seurat@meta.data$cluster_annotation_string <- cluster_annotations

# Visualizar
DimPlot(bm_seurat, group.by = "cluster_annotation_string", label = TRUE, repel = TRUE) + NoLegend()
```


### Compositional analysis

```{r}
#### compositional data analysis

# Calcular tabla de conteo por cluster y condición
count_table <- table(bm_seurat@meta.data$seurat_clusters, bm_seurat@meta.data$orig.ident)

# Convertir a matriz y normalizar a proporciones
counts <- as.matrix(count_table)
counts[counts == 0] <- 1e-6
props <- sweep(counts, 2, colSums(counts), FUN = "/")

# Crear data.frame largo
df_long <- data.frame(
  cluster = rep(rownames(props), times = ncol(props)),
  condition = rep(colnames(props), each = nrow(props)),
  proportion = as.vector(props)
)

# Mapear nombres descriptivos de los clusters
df_long$cluster_name <- annotations[as.character(df_long$cluster)]

# Definir orden de las condiciones (WT primero, luego KO)
df_long$condition <- factor(df_long$condition, levels = c("bm_WT", "bm_KO"))

# Ordenar clusters por nombre (o en el orden original si prefieres)
df_long$cluster_name <- factor(df_long$cluster_name, levels = unique(annotations))

# Crear paleta de colores sin repetir
n_clusters <- length(unique(df_long$cluster_name))
colors <- colorRampPalette(brewer.pal(12, "Paired"))(n_clusters)

# Gráfico final con nombres de clúster
ggplot(df_long, aes(x=condition, y=proportion, fill=cluster_name)) +
  geom_bar(stat="identity") +
  theme_minimal() +
  ylab("Cell proportions") +
  xlab("Condition") +
  scale_fill_manual(values=colors, name="Cluster") +
  ggtitle("Cluster distribution by condition") +
  theme(axis.text.x = element_text(angle=45, hjust=1))
```

Some statistics:

```{r}
# algo de estadística
# primero, hay diferencias entre wt y ko?
chisq.test(counts)

# ahora, vamos necesitamos construir una tabla 2×2 para cada cluster, comparando:
# ese cluster vs todos los demás, en las dos condiciones (spl_KO, spl_WT)
# el test evalúa si ese cluster está sobrerrepresentado o infrarrepresentado en KO respecto a WT.

pvals <- apply(counts, 1, function(x) {
  # x = c(spl_KO_cluster, spl_WT_cluster)
  rest_KO <- sum(counts[, "bm_KO"]) - x[1]
  rest_WT <- sum(counts[, "bm_WT"]) - x[2]
  
  mat <- matrix(c(x[1], x[2], rest_KO, rest_WT), nrow = 2)
  fisher.test(mat)$p.value
})
# Añadimos resultados
results <- data.frame(
  Cluster = rownames(counts),
  p.value = pvals,
  adj.p.value = p.adjust(pvals, method = "BH")
)
# Log2 fold change de proporción KO vs WT
log2fc <- log2(props[, "bm_KO"] / props[, "bm_WT"])
results$log2FC <- log2fc
results <- results[order(results$p.value), ]
# Añadir nombres descriptivos de los clusters
results$cluster_name <- annotations[as.character(results$Cluster)]
kable(results)
```

La gráfica: 

```{r}
# podemos plotear
ggplot(results, aes(x = log2FC, y = -log10(p.value), label = cluster_name)) +
  geom_point(aes(color = adj.p.value < 0.05), size = 3, alpha = 0.8) +
  geom_text(data = subset(results, adj.p.value < 0.05),
            vjust = -0.8, size = 3.2, color = "black") +
  scale_color_manual(values = c("grey60", "red")) +
  theme_minimal() +
  labs(x = "log2(FC KO vs WT)",
       y = "-log10(p-value)",
       color = "Significant (FDR < 0.05)",
       title = "Cluster proportion changes (KO vs WT)") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50")
```

### Immune data

```{r}
### annotation unbiased using reference

expr <- GetAssayData(bm_seurat, assay = "integrated", slot = "data")

bm_sce <- SingleCellExperiment(
  assays = list(logcounts = expr),
  colData = bm_seurat@meta.data
)

# Referencia de ratón
# otro puede ser:
# MouseRNAseqData()
ref <- celldex::ImmGenData()

pred_bm <- SingleR(test = bm_sce, ref = ref, labels = ref$label.fine)

# Añadir anotación al Seurat
bm_seurat$SingleR_labels <- pred_bm$labels
bm_seurat$SingleR_clean <- gsub("\\s*\\([^\\)]+\\)", "", bm_seurat$SingleR_labels)

DimPlot(bm_seurat, group.by = "SingleR_clean", label = TRUE, repel = TRUE) + NoLegend()
```

### Compositional analysis 

```{r}
#### compositional data analysis

#  count_table con nombres de clusters reales
count_table <- table(bm_seurat@meta.data$SingleR_clean,
                     bm_seurat@meta.data$orig.ident)

# Convertir a matriz
counts <- as.matrix(count_table)

# Reemplazar ceros por un valor pequeño
counts[counts == 0] <- 1e-6

# Proporciones por columna
props <- sweep(counts, 2, colSums(counts), FUN = "/")

# df_long
df_long <- data.frame(
  cluster = rep(rownames(props), times = ncol(props)),
  condition = rep(colnames(props), each = nrow(props)),
  proportion = as.vector(props)
)

# Definir orden de condiciones (WT primero, luego KO)
df_long$condition <- factor(df_long$condition, levels = c("bm_WT", "bm_KO"))

# Orden de clusters según el orden en props
df_long$cluster <- factor(df_long$cluster, levels = rownames(props))

# Paleta con colores únicos
n_clusters <- length(unique(df_long$cluster))
colors <- colorRampPalette(brewer.pal(12, "Paired"))(n_clusters)

# Gráfico
ggplot(df_long, aes(x=condition, y=proportion, fill=cluster)) +
  geom_bar(stat="identity") +
  theme_minimal() +
  ylab("Cell proportions") +
  xlab("Condition") +
  scale_fill_manual(values=colors, name="Cluster") +
  ggtitle("Cluster distribution by condition")
```



```{r}
# --- Preparación: normalizar por cluster (fila) para que cada cluster sea 100% ---
# counts: matrix con filas = clusters, columnas = condiciones (ej. bm_KO, bm_WT)

# Normalizar por fila (cada fila suma 1)
row_props <- sweep(counts, 1, rowSums(counts), FUN = "/")
# Convertir a porcentajes
row_percent <- row_props * 100

# Asegurar orden de clusters si tienen nombres numéricos:
if(all(rownames(row_percent) %in% as.character(as.numeric(rownames(row_percent))))) {
  row_percent <- row_percent[order(as.numeric(rownames(row_percent))), , drop = FALSE]
}

# Transponer para heatmap: filas = condiciones, columnas = clusters
heatmap_mat <- t(row_percent)

# Reordenar filas (condiciones) si quieres WT primero:
desired_cond_order <- c("bm_WT", "bm_KO")
if(all(desired_cond_order %in% rownames(heatmap_mat))) {
  heatmap_mat <- heatmap_mat[desired_cond_order, , drop = FALSE]
}

pheatmap(
  heatmap_mat,
  cluster_rows = FALSE,   # no reagrupar condiciones
  cluster_cols = FALSE,   # no reagrupar clusters
  color = colorRampPalette(c("white", "steelblue"))(100),
  display_numbers = TRUE,
  number_format = "%.1f", # formato con 1 decimal
  fontsize_number = 10,
  main = "Percentage of cells per cluster (each cluster = 100%)",
  legend = TRUE,
  angle_col = 45
)
```

Some statistics:

```{r}
# algo de estadística
# primero, hay diferencias entre wt y ko?
chisq.test(counts)

# ahora, vamos necesitamos construir una tabla 2×2 para cada cluster, comparando:
# ese cluster vs todos los demás, en las dos condiciones (spl_KO, spl_WT)
# el test evalúa si ese cluster está sobrerrepresentado o infrarrepresentado en KO respecto a WT.

pvals <- apply(counts, 1, function(x) {
  # x = c(spl_KO_cluster, spl_WT_cluster)
  rest_KO <- sum(counts[, "bm_KO"]) - x[1]
  rest_WT <- sum(counts[, "bm_WT"]) - x[2]
  
  mat <- matrix(c(x[1], x[2], rest_KO, rest_WT), nrow = 2)
  fisher.test(mat)$p.value
})
# Añadimos resultados
results <- data.frame(
  Cluster = rownames(counts),
  p.value = pvals,
  adj.p.value = p.adjust(pvals, method = "BH")
)
# Log2 fold change de proporción KO vs WT
log2fc <- log2(props[, "bm_KO"] / props[, "bm_WT"])
results$log2FC <- log2fc
results <- results[order(results$p.value), ]
# Añadir nombres descriptivos de los clusters
kable(results)
```

La gráfica: 

```{r}
# podemos plotear
ggplot(results, aes(x = log2FC, y = -log10(p.value), label = Cluster)) +
  geom_point(aes(color = adj.p.value < 0.05), size = 3, alpha = 0.8) +
  geom_text(data = subset(results, adj.p.value < 0.05),
            vjust = -0.8, size = 3.2, color = "black") +
  scale_color_manual(values = c("grey60", "red")) +
  theme_minimal() +
  labs(x = "log2(FC KO vs WT)",
       y = "-log10(p-value)",
       color = "Significant (FDR < 0.05)",
       title = "Cluster proportion changes (KO vs WT)") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey50")
```

### MouseRNAseqData

```{r}
### annotation unbiased using reference

expr <- GetAssayData(bm_seurat, assay = "integrated", slot = "data")

bm_sce <- SingleCellExperiment(
  assays = list(logcounts = expr),
  colData = bm_seurat@meta.data
)

# Referencia de ratón
# otro puede ser:
# MouseRNAseqData()
ref <- celldex::MouseRNAseqData()

pred_bm <- SingleR(test = bm_sce, ref = ref, labels = ref$label.fine)

# Añadir anotación al Seurat
bm_seurat$SingleR_labels <- pred_bm$labels
bm_seurat$SingleR_clean <- gsub("\\s*\\([^\\)]+\\)", "", bm_seurat$SingleR_labels)

DimPlot(bm_seurat, group.by = "SingleR_clean", label = TRUE, repel = TRUE) + NoLegend()
```

### Compositional analysis 

```{r}
#### compositional data analysis

#  count_table con nombres de clusters reales
count_table <- table(bm_seurat@meta.data$SingleR_clean,
                     bm_seurat@meta.data$orig.ident)

# Convertir a matriz
counts <- as.matrix(count_table)

# Reemplazar ceros por un valor pequeño
counts[counts == 0] <- 1e-6

# Proporciones por columna
props <- sweep(counts, 2, colSums(counts), FUN = "/")

# df_long
df_long <- data.frame(
  cluster = rep(rownames(props), times = ncol(props)),
  condition = rep(colnames(props), each = nrow(props)),
  proportion = as.vector(props)
)

# Definir orden de condiciones (WT primero, luego KO)
df_long$condition <- factor(df_long$condition, levels = c("bm_WT", "bm_KO"))

# Orden de clusters según el orden en props
df_long$cluster <- factor(df_long$cluster, levels = rownames(props))

# Paleta con colores únicos
n_clusters <- length(unique(df_long$cluster))
colors <- colorRampPalette(brewer.pal(12, "Paired"))(n_clusters)

# Gráfico
ggplot(df_long, aes(x=condition, y=proportion, fill=cluster)) +
  geom_bar(stat="identity") +
  theme_minimal() +
  ylab("Cell proportions") +
  xlab("Condition") +
  scale_fill_manual(values=colors, name="Cluster") +
  ggtitle("Cluster distribution by condition")
```

```{r}
# --- Preparación: normalizar por cluster (fila) para que cada cluster sea 100% ---
# counts: matrix con filas = clusters, columnas = condiciones (ej. bm_KO, bm_WT)

# Normalizar por fila (cada fila suma 1)
row_props <- sweep(counts, 1, rowSums(counts), FUN = "/")
# Convertir a porcentajes
row_percent <- row_props * 100

# Asegurar orden de clusters si tienen nombres numéricos:
if(all(rownames(row_percent) %in% as.character(as.numeric(rownames(row_percent))))) {
  row_percent <- row_percent[order(as.numeric(rownames(row_percent))), , drop = FALSE]
}

# Transponer para heatmap: filas = condiciones, columnas = clusters
heatmap_mat <- t(row_percent)

# Reordenar filas (condiciones) si quieres WT primero:
desired_cond_order <- c("bm_WT", "bm_KO")
if(all(desired_cond_order %in% rownames(heatmap_mat))) {
  heatmap_mat <- heatmap_mat[desired_cond_order, , drop = FALSE]
}

pheatmap(
  heatmap_mat,
  cluster_rows = FALSE,   # no reagrupar condiciones
  cluster_cols = FALSE,   # no reagrupar clusters
  color = colorRampPalette(c("white", "steelblue"))(100),
  display_numbers = TRUE,
  number_format = "%.1f", # formato con 1 decimal
  fontsize_number = 10,
  main = "Percentage of cells per cluster (each cluster = 100%)",
  legend = TRUE,
  angle_col = 45
)
```


# R session

```{r}
sessionInfo()
```

